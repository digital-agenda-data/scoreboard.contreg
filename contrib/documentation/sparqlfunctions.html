<ul>
  <li>See <a href="http://www.w3.org/TR/sparql11-query/">http://www.w3.org/TR/sparql11-query/</a></li>
  <li>See <a href="http://docs.openlinksw.com/virtuoso/rdfsparql.html">http://docs.openlinksw.com/virtuoso/rdfsparql.html</a></li>
</ul>
<h2 id="Aggregatefunctions">Aggregate functions</h2>
<table class="datatable">
  <tr>
    <th>Name</th>
    <th>Description</th>
    <th>Status</th>
  </tr>
  <tr>
    <td>AVG(<em>Expn</em>)</td>
    <td>Calculates the average value for an expression over a group</td>
    <td>Supported</td>
  </tr>
  <tr>
    <td>COUNT(<em>Expn</em>)</td>
    <td>Counts the number of times a given expression has a bound, and non-error value with the aggregate group</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>sql:GROUP_CONCAT(<em>Expn</em>,' ')</td>
    <td>Performs a string concatenation across the values of an expression with a group.</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>MAX(<em>Expn</em>)</td>
    <td>Returns the maximum value from a group</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>MIN(<em>Expn</em>)</td>
    <td>Returns the minimum value from a group</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>sql:SAMPLE(<em>Expn</em>)</td>
    <td>Returns an arbitrary value from the multiset passed to it.</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>SUM(<em>Expn</em>)</td>
    <td>Returns the numeric value obtained by summing the values within the aggregate group</td>
    <td>Supported </td>
  </tr>
</table>
<h2 id="Constructorfunctions">Constructor functions</h2>
<p>
These functions cast a value from one data type to another. See also <a href="http://www.w3.org/TR/xmlschema-2/#built-in-datatypes">http://www.w3.org/TR/xmlschema-2/#built-in-datatypes</a>

</p>
<table class="datatable">
  <tr>
    <th>Name</th>
    <th>Description</th>
    <th>Status</th>
  </tr>
  <tr>
    <td>xsd:string( <em>Expn</em>)</td>
    <td> Converts expression to a string, same as STR() (removes xsd:string attribute) </td>
    <td> Supported </td>
  </tr>
  <tr>
    <td>xsd:boolean( <em>Expn</em>)</td>
    <td> Converts expression to a boolean </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>xsd:decimal( <em>Expn</em>)</td>
    <td> Converts expression to a decimal, i.e. 3.14 </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>xsd:integer( <em>Expn</em>)</td>
    <td> Converts expression to an integer </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>xsd:float( <em>Expn</em>)</td>
    <td> Converts expression to a float - like a decimal but with limited precision </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>xsd:double( <em>Expn</em>)</td>
    <td> Converts expression to a float - like a decimal but with less limited precision </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>xsd:dateTime( <em>Expn</em>)</td>
    <td> Converts expression to a date-time ("2011-04-09T12:21:23") </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>xsd:time( <em>Expn</em>)</td>
    <td> Converts expression to a date-time ("2011-04-09T12:21:23+02:00") </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>xsd:date( <em>Expn</em>)</td>
    <td> Converts expression to a date ("2011-04-09") </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>xsd:gYear( <em>Expn</em>)</td>
    <td> Converts expression to a year (Gregorian). Support: Can convert plain strings like "2011-05-05", but <em>not</em> expressions that are already xsd:dateTime or xsd:date types </td>
    <td> Partly 
</td>
  </tr>
  <tr>
    <td>xsd:gYearMonth( <em>Expn</em>)</td>
    <td> Converts expression to a year and month (Gregorian). Support: Same as for gYear </td>
    <td> Partly 

</td>
  </tr>
</table>
<h2 id="Expressionfunctions">Expression functions</h2>
<table class="datatable">
  <tr>
    <th>Name</th>
    <th>Description</th>
    <th>Status</th>
  </tr>
  <tr>
    <td>BOUND( <em>Var</em>)</td>
    <td>Returns true if <em>Var</em> is bound to a value. Returns false otherwise. Variables with the value NaN or INF are considered bound</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>DATATYPE( <em>Expn</em>)</td>
    <td>Returns the datatype IRI of <em>Expn</em>; returns xsd:string if the parameter is a simple literal</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>IRI( <em>Expn</em>)</td>
    <td>The IRI function constructs an IRI by resolving the string argument</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>isIRI( <em>Expn</em>)</td>
    <td>Returns true if term is an IRI. Returns false otherwise</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>isURI( <em>Expn</em>)</td>
    <td style="text-align: right"> isURI is an alternate spelling for the isIRI operator</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>isBLANK( <em>Expn</em>)</td>
    <td>Returns true if term is a blank node</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>isLITERAL( <em>Expn</em>)</td>
    <td>Returns true if term is a literal</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>isNUMERIC( <em>Expn</em>)</td>
    <td>Returns true if term is a numeric value</td>
    <td>Not supported </td>
  </tr>
  <tr>
    <td>LANG( <em>Expn</em>)</td>
    <td>Returns the language tag of <em>Expn</em>, if it has one</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>LANGMATCHES( <em>Expn1, Expn2</em>)</td>
    <td>Returns true if Expn1 matches Expn2 per the basic filtering scheme defined in <a href="http://www.ietf.org/rfc/rfc4647.txt">RFC4647</a> section 3.3.1.</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>STR( <em>Expn</em>)</td>
    <td>If <em>Expn</em> is a literal, returns the string without datatype and language code. If <em>Expn</em> is an IRI, then the IRI is returned as a string</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>STRLANG( <em>Expn1, Expn2</em>)</td>
    <td>constructs a literal with lexical form and language tag as specificed by the arguments</td>
    <td> ??  </td>
  </tr>
  <tr>
    <td>sameTERM( <em>Expn1, Expn2</em>)</td>
    <td>Returns TRUE if Expn1 and Expn2 are the same RDF term.</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>URI( <em>Expn</em>)</td>
    <td>The URI function is a synonym for IRI</td>
    <td> ??  </td>
  </tr>
</table>

<h2 id="SPARQL11functions">SPARQL 1.1 functions</h2>
<p>
<a href="http://www.w3.org/TR/sparql11-query/#SparqlOps">SPARQL 1.1</a> defines additional functions.
</p>
<p>
Actual support is unknown.
</p>
<table class="datatable">
  <tr>
    <td>fn:not(value)</td>
    <td>Logical negation of the boolean effective value of value.</td>
    <td> ??  </td>
  </tr>
  <tr>
    <td>contains(string, substr)</td>
    <td>Test whether substr occurs in string.</td>
    <td> ??  </td>
  </tr>
  <tr>
    <td>strstarts(string, match)</td>
    <td>Test whether string starts with substr.</td>
    <td> ??  </td>
  </tr>
  <tr>
    <td>strends(string, match)</td>
    <td>Test whether string ends with substr.</td>
    <td> ??  </td>
  </tr>
  <tr>
    <td>strlen(string)</td>
    <td>Return the length of a string.</td>
    <td> ??  </td>
  </tr>
  <tr>
    <td>lcase(string)</td>
    <td>Return a string which is the lower case equivalent of the argument.</td>
    <td> ??  </td>
  </tr>
  <tr>
    <td>ucase(string)</td>
    <td>Return a string which is the upper case equivalent of the argument.</td>
    <td> ??  </td>
  </tr>
  <tr>
    <td>regex(string, pattern [, flags])</td>
    <td>Regular expression match.</td>
    <td> Supported  </td>
  </tr>
  <tr>
    <td>concat(string, ...)</td>
    <td>Return the concatenation of strings.</td>
    <td> ??  </td>
  </tr>
  <tr>
    <td>substr(string, begin [,length])</td>
    <td>Returns the substring of a string, given by begin  (integer) and, optionally, length length.  Absence of length means to end of string.
     The index of the first character in a strings is 1.</td>
    <td> ?? </td>
  </tr>
  <tr>
    <td>round(v)</td>
    <td>Return the nearest integer value to the argument.</td>
    <td> ??  </td>
  </tr>
  <tr>
    <td>abs(v)</td>
    <td>Return the absolute value.</td>
    <td> ??  </td>
  </tr>
  <tr>
    <td>floor(v)</td>
    <td>Return the greatest integer value less than the argument (as a double).</td>
    <td> ??  </td>
  </tr>
  <tr>
    <td>ceil(v)</td>
    <td>Return the smallest integer value than the argument (as a double).</td>
    <td> ?? </td>
  </tr>
</table>
<h2 id="Virtuosobuilt-infunctions">Virtuoso built-in functions</h2>
<p>
Many more are documented here: <a href="http://docs.openlinksw.com/virtuoso/functions.html">http://docs.openlinksw.com/virtuoso/functions.html</a>
</p>
<table class="datatable">
  <tr>
    <td>bif:substring( <em>string, start, length</em>)</td>
    <td>Substitute for substr. First character has index 1.</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>bif:strchr( <em>string, char</em>)</td>
    <td>Finds the position of <em>char</em> in string.</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>bif:concat( <em>string,...</em>)</td>
    <td> </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>bif:contains</td>
    <td>Pseudo-predicate for full-text search. If right-side literal is contained the value of left-side URIRef, then the query matches. Can also be used as a function</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>bif:xcontains</td>
    <td>Search using XPATH expressions</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>bif:search_excerpt</td>
    <td> </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>bif:year( <em>Expn</em>)</td>
    <td>Returns the year of a date, dateTime or time argument</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>bif:dateadd ( <em>String, Integer, Date</em>)</td>
    <td>Example: bif:dateadd ("day", -90, '1998-12-01'<sup/>xsd:date))</td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>bif:exists</td>
    <td style="text-align: left">Used for ASK subqueries </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>bif:stringdate( <em>String</em>)</td>
    <td> Converts string to date </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>bif:sum( <em>Expn</em>)</td>
    <td> Same as SUM() </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>bif:number( <em>Expn</em>)</td>
    <td> Converts string to number </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>bif:isnull( <em>Expn</em>)</td>
    <td> Returns true if expression returns null </td>
    <td>Supported </td>
  </tr>
  <tr>
    <td>bif:sprintf( <em>format, varargs</em>)</td>
    <td> Returns a formatted string </td>
    <td>Supported </td>
  </tr>
</table>
